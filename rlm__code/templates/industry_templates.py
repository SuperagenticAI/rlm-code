"""
Industry-standard DSPy templates for common use cases.

These templates provide complete, working implementations for real-world applications.
"""

from dataclasses import dataclass


@dataclass
class TemplateInfo:
    """Information about a template."""

    name: str
    display_name: str
    description: str
    use_cases: list[str]
    components: list[str]
    difficulty: str
    keywords: list[str]


class IndustryTemplates:
    """Registry of industry-standard DSPy templates."""

    def __init__(self):
        self.templates = {
            "rag_chatbot": self._rag_chatbot_info(),
            "customer_support": self._customer_support_info(),
            "research_agent": self._research_agent_info(),
            "travel_booking": self._travel_booking_info(),
        }

    def list_all(self) -> list[TemplateInfo]:
        """List all available templates."""
        return list(self.templates.values())

    def get_template_code(self, name: str) -> str | None:
        """Get complete code for a template."""
        generators = {
            "rag_chatbot": self._generate_rag_chatbot,
            "customer_support": self._generate_customer_support,
            "research_agent": self._generate_research_agent,
            "travel_booking": self._generate_travel_booking,
        }

        generator = generators.get(name)
        return generator() if generator else None

    def search(self, query: str) -> list[TemplateInfo]:
        """Search templates by keywords."""
        query_lower = query.lower()
        matches = []

        for template in self.templates.values():
            # Check keywords
            if any(kw in query_lower for kw in template.keywords) or any(
                uc.lower() in query_lower for uc in template.use_cases
            ):
                matches.append(template)

        return matches

    # Template Info Methods
    def _rag_chatbot_info(self) -> TemplateInfo:
        return TemplateInfo(
            name="rag_chatbot",
            display_name="RAG Chatbot",
            description="Retrieval-Augmented Generation chatbot for Q&A over documents",
            use_cases=["Document Q&A", "Knowledge base chatbot", "Customer documentation"],
            components=["Retriever", "ChainOfThought", "Context management"],
            difficulty="intermediate",
            keywords=["rag", "retrieval", "chatbot", "documents", "knowledge base", "q&a"],
        )

    def _customer_support_info(self) -> TemplateInfo:
        return TemplateInfo(
            name="customer_support",
            display_name="Customer Support Agent",
            description="Automated customer support agent with tools and escalation",
            use_cases=["Customer service", "Help desk", "Support automation"],
            components=["ReAct", "Tools", "Memory", "Escalation logic"],
            difficulty="intermediate",
            keywords=["customer support", "help desk", "support agent", "tickets", "automation"],
        )

    def _research_agent_info(self) -> TemplateInfo:
        return TemplateInfo(
            name="research_agent",
            display_name="Research Assistant",
            description="Multi-hop reasoning agent for research with citations",
            use_cases=["Research", "Fact-checking", "Report generation"],
            components=["ReAct", "Search tools", "Multi-hop reasoning", "Citations"],
            difficulty="advanced",
            keywords=["research", "fact check", "citations", "multi-hop", "investigation"],
        )

    def _travel_booking_info(self) -> TemplateInfo:
        return TemplateInfo(
            name="travel_booking",
            display_name="Travel Booking Agent",
            description="Travel booking agent with search, comparison, and booking tools",
            use_cases=["Travel booking", "Flight search", "Hotel booking"],
            components=["ReAct", "Search tools", "Comparison", "Booking tools"],
            difficulty="advanced",
            keywords=["travel", "booking", "flights", "hotels", "reservation", "trip"],
        )

    # Template Generation Methods
    def _generate_rag_chatbot(self) -> str:
        """Generate complete RAG chatbot code."""
        return '''"""
RAG Chatbot - Retrieval-Augmented Generation System

A complete chatbot that answers questions by retrieving relevant information
from a document collection and generating informed responses.

Generated by RLM Code from industry template.
"""

import dspy
from dspy.retrieve import ColBERTv2

# ============================================================================
# 1. SIGNATURES
# ============================================================================

class GenerateAnswer(dspy.Signature):
    """Answer questions based on retrieved context."""

    question = dspy.InputField(desc="User's question")
    context = dspy.InputField(desc="Retrieved relevant documents")
    history = dspy.InputField(desc="Conversation history (optional)")
    answer = dspy.OutputField(desc="Answer with citations")


# ============================================================================
# 2. RAG CHATBOT MODULE
# ============================================================================

class RAGChatbot(dspy.Module):
    """RAG chatbot with retrieval and generation."""

    def __init__(self, retriever):
        super().__init__()
        self.retriever = retriever
        self.generator = dspy.ChainOfThought(GenerateAnswer)
        self.conversation_history = []

    def forward(self, question, k=5):
        """
        Answer a question using retrieval and generation.

        Args:
            question: User's question
            k: Number of documents to retrieve

        Returns:
            Answer with context
        """
        # Retrieve relevant documents
        retrieved_docs = self.retriever(question, k=k)

        # Format context
        context = "\\n\\n".join([
            f"[{i+1}] {doc['text']}"
            for i, doc in enumerate(retrieved_docs)
        ])

        # Format history
        history = "\\n".join([
            f"Q: {h['question']}\\nA: {h['answer']}"
            for h in self.conversation_history[-3:]  # Last 3 turns
        ])

        # Generate answer
        result = self.generator(
            question=question,
            context=context,
            history=history if history else "No previous conversation"
        )

        # Update history
        self.conversation_history.append({
            "question": question,
            "answer": result.answer
        })

        return result.answer


# ============================================================================
# 3. DOCUMENT INDEXING
# ============================================================================

def index_documents(document_dir="data/documents"):
    """Index documents for retrieval."""
    from pathlib import Path

    doc_path = Path(document_dir)

    if not doc_path.exists():
        print(f"⚠️  Document directory not found: {document_dir}")
        print("Creating example documents...")

        doc_path.mkdir(parents=True, exist_ok=True)

        # Create example documents
        (doc_path / "doc1.txt").write_text(
            "DSPy is a framework for programming with foundation models. "
            "It provides abstractions for building complex LM systems."
        )
        (doc_path / "doc2.txt").write_text(
            "GEPA is an optimizer that uses reflection to evolve prompts. "
            "It can significantly improve DSPy program performance."
        )

        print(f"✓ Created example documents in {document_dir}")
        print("  Add your own documents to this directory\\n")

    # Load documents
    documents = []
    for doc_file in doc_path.glob("*.txt"):
        text = doc_file.read_text()
        documents.append({"text": text, "source": doc_file.name})

    print(f"✓ Loaded {len(documents)} documents")
    return documents


# ============================================================================
# 4. CONFIGURATION
# ============================================================================

def configure_rag_system():
    """Configure DSPy and retriever."""

    # Configure language model (DSPy 3.0+)
    lm = dspy.LM(model='ollama/gpt-oss:20b')
    dspy.configure(lm=lm)
    print("✓ Configured language model")

    # Configure retriever
    # Option 1: ColBERTv2 (recommended for production)
    # retriever = ColBERTv2(url='http://localhost:8893/api/search')

    # Option 2: Simple in-memory retriever (for demo)
    from dspy.retrieve import retrieve
    documents = index_documents()

    def simple_retriever(query, k=5):
        # Simple keyword-based retrieval (replace with ColBERT for production)
        results = []
        for doc in documents:
            if any(word.lower() in doc['text'].lower() for word in query.split()):
                results.append(doc)
        return results[:k]

    print("✓ Configured retriever")
    print("  Note: Using simple retriever. For production, use ColBERTv2\\n")

    return simple_retriever


# ============================================================================
# 5. MAIN PROGRAM
# ============================================================================

def main():
    """Run the RAG chatbot."""

    print("\\n" + "="*60)
    print("RAG Chatbot - Retrieval-Augmented Generation")
    print("="*60 + "\\n")

    # Configure system
    retriever = configure_rag_system()

    # Create chatbot
    chatbot = RAGChatbot(retriever)
    print("✓ RAG Chatbot ready\\n")

    # Example usage
    print("Example Question:")
    print("-" * 60)
    question = "What is DSPy?"
    print(f"Q: {question}")

    answer = chatbot(question=question)
    print(f"A: {answer}")
    print("-" * 60)
    print()

    # Interactive mode
    print("Interactive Mode (Ctrl+C to exit):")
    print("Ask questions about your documents\\n")

    try:
        while True:
            question = input("Q: ").strip()
            if not question:
                continue

            answer = chatbot(question=question)
            print(f"A: {answer}\\n")

    except KeyboardInterrupt:
        print("\\n\\nGoodbye!")


# ============================================================================
# 6. NEXT STEPS
# ============================================================================

"""
NEXT STEPS TO IMPROVE YOUR RAG CHATBOT:

1. Production Retriever:
   - Set up ColBERTv2 server
   - Index your documents properly
   - Use semantic search instead of keyword matching

2. Better Context:
   - Add document metadata (title, date, source)
   - Implement reranking
   - Add relevance filtering

3. Citations:
   - Track which documents were used
   - Include source references in answers
   - Add confidence scores

4. Evaluation:
   - Create test Q&A pairs
   - Measure answer quality
   - Track retrieval accuracy

5. Optimization:
   - Use GEPA to optimize prompts
   - Improve retrieval quality
   - Fine-tune generation

6. Production Features:
   - Add conversation persistence
   - Implement user sessions
   - Add rate limiting
   - Deploy as API
"""


if __name__ == "__main__":
    main()
'''

    def _generate_travel_booking(self) -> str:
        """Generate complete travel booking agent code."""
        return '''"""
Travel Booking Agent - Multi-step Planning with Constraints

A complete travel booking agent that can search flights, hotels, activities,
handle constraints, optimize itineraries, and provide personalized recommendations.

Generated by RLM Code from industry template.
"""

import dspy
from dspy import Tool
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional

# ============================================================================
# 1. SIGNATURES
# ============================================================================

class TravelPlanningSignature(dspy.Signature):
    """Plan travel itinerary with constraints."""

    destination = dspy.InputField(desc="Travel destination")
    dates = dspy.InputField(desc="Travel dates (start and end)")
    budget = dspy.InputField(desc="Budget constraints")
    preferences = dspy.InputField(desc="User preferences and requirements")
    itinerary = dspy.OutputField(desc="Complete travel itinerary with bookings")


class OptimizeItinerary(dspy.Signature):
    """Optimize travel itinerary for cost, time, or experience."""

    current_itinerary = dspy.InputField(desc="Current itinerary")
    optimization_goal = dspy.InputField(desc="What to optimize (cost, time, experience)")
    constraints = dspy.InputField(desc="Hard constraints that must be met")
    optimized_itinerary = dspy.OutputField(desc="Optimized itinerary")


# ============================================================================
# 2. TRAVEL TOOLS
# ============================================================================

def search_flights(origin: str, destination: str, date: str, passengers: int = 1) -> str:
    """
    Search for available flights.

    Args:
        origin: Departure city/airport
        destination: Arrival city/airport
        date: Travel date (YYYY-MM-DD)
        passengers: Number of passengers

    Returns:
        Available flight options
    """
    # Mock flight data - replace with real flight API (Amadeus, Skyscanner, etc.)
    mock_flights = [
        {
            "airline": "United Airlines",
            "flight_number": "UA1234",
            "departure": f"{date} 08:00",
            "arrival": f"{date} 11:30",
            "duration": "3h 30m",
            "price": 250 * passengers,
            "stops": 0
        },
        {
            "airline": "Delta",
            "flight_number": "DL5678",
            "departure": f"{date} 14:00",
            "arrival": f"{date} 18:00",
            "duration": "4h 00m",
            "price": 180 * passengers,
            "stops": 1
        },
        {
            "airline": "Southwest",
            "flight_number": "SW9012",
            "departure": f"{date} 18:30",
            "arrival": f"{date} 22:15",
            "duration": "3h 45m",
            "price": 220 * passengers,
            "stops": 0
        }
    ]

    # Format results
    results = []
    for flight in mock_flights:
        results.append(
            f"{flight['airline']} {flight['flight_number']}\\n"
            f"  {origin} → {destination}\\n"
            f"  Departure: {flight['departure']} | Arrival: {flight['arrival']}\\n"
            f"  Duration: {flight['duration']} | Stops: {flight['stops']}\\n"
            f"  Price: ${flight['price']} for {passengers} passenger(s)"
        )

    return f"Flights from {origin} to {destination} on {date}:\\n\\n" + "\\n\\n".join(results)


def search_hotels(location: str, check_in: str, check_out: str, guests: int = 1) -> str:
    """
    Search for available hotels.

    Args:
        location: Hotel location
        check_in: Check-in date (YYYY-MM-DD)
        check_out: Check-out date (YYYY-MM-DD)
        guests: Number of guests

    Returns:
        Available hotel options
    """
    # Mock hotel data - replace with real hotel API (Booking.com, Hotels.com, etc.)
    mock_hotels = [
        {
            "name": "Grand Plaza Hotel",
            "rating": 4.5,
            "price_per_night": 150,
            "amenities": ["WiFi", "Pool", "Gym", "Breakfast"],
            "distance_to_center": "0.5 miles"
        },
        {
            "name": "Budget Inn",
            "rating": 3.8,
            "price_per_night": 80,
            "amenities": ["WiFi", "Parking"],
            "distance_to_center": "2 miles"
        },
        {
            "name": "Luxury Resort & Spa",
            "rating": 5.0,
            "price_per_night": 300,
            "amenities": ["WiFi", "Pool", "Spa", "Restaurant", "Beach Access"],
            "distance_to_center": "1 mile"
        }
    ]

    # Calculate nights
    check_in_date = datetime.strptime(check_in, "%Y-%m-%d")
    check_out_date = datetime.strptime(check_out, "%Y-%m-%d")
    nights = (check_out_date - check_in_date).days

    # Format results
    results = []
    for hotel in mock_hotels:
        total_price = hotel['price_per_night'] * nights
        results.append(
            f"{hotel['name']} ({'⭐' * int(hotel['rating'])})\\n"
            f"  Rating: {hotel['rating']}/5.0\\n"
            f"  Price: ${hotel['price_per_night']}/night × {nights} nights = ${total_price}\\n"
            f"  Amenities: {', '.join(hotel['amenities'])}\\n"
            f"  Location: {hotel['distance_to_center']} from city center"
        )

    return f"Hotels in {location} ({check_in} to {check_out}):\\n\\n" + "\\n\\n".join(results)


def search_activities(location: str, date: str, interests: str = "general") -> str:
    """
    Search for activities and attractions.

    Args:
        location: Activity location
        date: Date for activities
        interests: User interests (adventure, culture, food, etc.)

    Returns:
        Available activities
    """
    # Mock activity data - replace with real API (Viator, GetYourGuide, etc.)
    mock_activities = {
        "adventure": [
            {"name": "Zip Line Tour", "duration": "3 hours", "price": 75, "rating": 4.7},
            {"name": "Hiking Expedition", "duration": "5 hours", "price": 50, "rating": 4.5}
        ],
        "culture": [
            {"name": "Museum Tour", "duration": "2 hours", "price": 25, "rating": 4.6},
            {"name": "Historical Walking Tour", "duration": "3 hours", "price": 30, "rating": 4.8}
        ],
        "food": [
            {"name": "Food Tasting Tour", "duration": "3 hours", "price": 60, "rating": 4.9},
            {"name": "Cooking Class", "duration": "4 hours", "price": 80, "rating": 4.7}
        ],
        "general": [
            {"name": "City Sightseeing Tour", "duration": "4 hours", "price": 40, "rating": 4.5},
            {"name": "Boat Cruise", "duration": "2 hours", "price": 35, "rating": 4.6}
        ]
    }

    activities = mock_activities.get(interests.lower(), mock_activities["general"])

    # Format results
    results = []
    for activity in activities:
        results.append(
            f"{activity['name']} ({'⭐' * int(activity['rating'])})\\n"
            f"  Duration: {activity['duration']}\\n"
            f"  Price: ${activity['price']} per person\\n"
            f"  Rating: {activity['rating']}/5.0"
        )

    return f"Activities in {location} on {date} ({interests}):\\n\\n" + "\\n\\n".join(results)


def check_travel_restrictions(destination: str) -> str:
    """
    Check travel restrictions and requirements.

    Args:
        destination: Destination country/city

    Returns:
        Travel restrictions and requirements
    """
    # Mock restriction data - replace with real API (IATA, government sources)
    mock_restrictions = {
        "visa_required": False,
        "covid_test": "Not required",
        "vaccination": "Recommended but not required",
        "travel_advisory": "Level 1 - Exercise Normal Precautions",
        "entry_requirements": ["Valid passport (6 months validity)", "Return ticket"]
    }

    return f"""Travel Requirements for {destination}:

Visa: {'Required' if mock_restrictions['visa_required'] else 'Not Required'}
COVID-19 Test: {mock_restrictions['covid_test']}
Vaccination: {mock_restrictions['vaccination']}
Travel Advisory: {mock_restrictions['travel_advisory']}

Entry Requirements:
{chr(10).join(f"  • {req}" for req in mock_restrictions['entry_requirements'])}

Note: Requirements may change. Verify with official sources before travel.
"""


# ============================================================================
# 3. TRAVEL BOOKING AGENT
# ============================================================================

class TravelBookingAgent(dspy.Module):
    """Travel booking agent with multi-step planning."""

    def __init__(self):
        super().__init__()

        # Define travel tools
        self.tools = [
            Tool(
                func=search_flights,
                name="search_flights",
                desc="Search for available flights"
            ),
            Tool(
                func=search_hotels,
                name="search_hotels",
                desc="Search for available hotels"
            ),
            Tool(
                func=search_activities,
                name="search_activities",
                desc="Search for activities and attractions"
            ),
            Tool(
                func=check_travel_restrictions,
                name="check_restrictions",
                desc="Check travel restrictions and requirements"
            )
        ]

        # Create planning components
        self.planner = dspy.ReAct(TravelPlanningSignature, tools=self.tools)
        self.optimizer = dspy.ChainOfThought(OptimizeItinerary)

        # Booking sessions
        self.booking_sessions = {}

    def forward(self, destination: str, dates: str, budget: str,
                preferences: str = "general", session_id: str = "default"):
        """
        Plan complete travel itinerary.

        Args:
            destination: Travel destination
            dates: Travel dates (e.g., "2024-03-15 to 2024-03-20")
            budget: Budget (e.g., "$2000")
            preferences: User preferences
            session_id: Session identifier

        Returns:
            Complete travel itinerary
        """
        # Create or get session
        if session_id not in self.booking_sessions:
            self.booking_sessions[session_id] = {
                "itineraries": [],
                "bookings": []
            }

        # Plan itinerary
        itinerary = self.planner(
            destination=destination,
            dates=dates,
            budget=budget,
            preferences=preferences
        )

        # Store itinerary
        self.booking_sessions[session_id]["itineraries"].append({
            "destination": destination,
            "dates": dates,
            "budget": budget,
            "itinerary": itinerary.itinerary,
            "timestamp": datetime.now().isoformat()
        })

        return itinerary.itinerary

    def optimize(self, session_id: str, goal: str = "cost"):
        """
        Optimize existing itinerary.

        Args:
            session_id: Session identifier
            goal: Optimization goal (cost, time, experience)

        Returns:
            Optimized itinerary
        """
        if session_id not in self.booking_sessions:
            return "No itinerary found for this session."

        session = self.booking_sessions[session_id]
        if not session["itineraries"]:
            return "No itinerary to optimize."

        current = session["itineraries"][-1]

        optimized = self.optimizer(
            current_itinerary=current["itinerary"],
            optimization_goal=goal,
            constraints=f"Budget: {current['budget']}, Dates: {current['dates']}"
        )

        return optimized.optimized_itinerary


# ============================================================================
# 4. CONFIGURATION
# ============================================================================

def configure_travel_system():
    """Configure DSPy for travel booking."""

    # Configure language model (DSPy 3.0+)
    lm = dspy.LM(model='ollama/gpt-oss:20b')
    dspy.configure(lm=lm)
    print("✓ Configured language model")

    # Create travel agent
    agent = TravelBookingAgent()
    print("✓ Travel booking agent ready")
    print("  Available tools: search_flights, search_hotels, search_activities, check_restrictions\\n")

    return agent


# ============================================================================
# 5. MAIN PROGRAM
# ============================================================================

def main():
    """Run the travel booking agent."""

    print("\\n" + "="*60)
    print("Travel Booking Agent - Multi-step Planning")
    print("="*60 + "\\n")

    # Configure system
    agent = configure_travel_system()

    # Example booking
    print("Example Travel Planning:")
    print("-" * 60)

    itinerary = agent(
        destination="Paris, France",
        dates="2024-06-01 to 2024-06-07",
        budget="$3000",
        preferences="culture and food",
        session_id="demo"
    )

    print(f"Travel Itinerary:\\n{itinerary}\\n")
    print("-" * 60)
    print()

    # Interactive mode
    print("Interactive Travel Planning (Ctrl+C to exit):")
    print("Plan your next trip!\\n")

    try:
        session_id = input("Enter session ID (or press Enter for default): ").strip()
        if not session_id:
            session_id = f"session_{datetime.now().strftime('%Y%m%d%H%M%S')}"

        print(f"\\nTravel planning session: {session_id}")
        print("Let's plan your trip!\\n")

        destination = input("Where do you want to go? ").strip()
        dates = input("Travel dates (e.g., 2024-06-01 to 2024-06-07): ").strip()
        budget = input("Budget (e.g., $2000): ").strip()
        preferences = input("Preferences (e.g., adventure, culture, relaxation): ").strip()

        print("\\nPlanning your itinerary...\\n")

        itinerary = agent(
            destination=destination,
            dates=dates,
            budget=budget,
            preferences=preferences or "general",
            session_id=session_id
        )

        print(f"Your Travel Itinerary:\\n{itinerary}\\n")

        # Optimization option
        optimize = input("Would you like to optimize this itinerary? (yes/no): ").strip().lower()
        if optimize == "yes":
            goal = input("Optimize for (cost/time/experience): ").strip().lower()
            optimized = agent.optimize(session_id=session_id, goal=goal or "cost")
            print(f"\\nOptimized Itinerary:\\n{optimized}\\n")

    except KeyboardInterrupt:
        print("\\n\\nTravel planning session ended. Safe travels!")


# ============================================================================
# 6. NEXT STEPS
# ============================================================================

"""
NEXT STEPS TO IMPROVE YOUR TRAVEL BOOKING AGENT:

1. Real Booking APIs:
   - Flight APIs (Amadeus, Skyscanner, Kiwi.com)
   - Hotel APIs (Booking.com, Expedia, Hotels.com)
   - Activity APIs (Viator, GetYourGuide)
   - Car rental APIs (Kayak, Rentalcars.com)

2. Payment Integration:
   - Stripe or PayPal integration
   - Secure payment processing
   - Booking confirmations
   - Refund handling

3. Advanced Features:
   - Multi-city itineraries
   - Group travel planning
   - Travel insurance options
   - Visa application assistance
   - Currency conversion
   - Weather forecasts

4. Personalization:
   - User profiles and preferences
   - Past trip history
   - Loyalty program integration
   - Personalized recommendations
   - Budget tracking

5. Real-time Updates:
   - Flight status monitoring
   - Price alerts
   - Travel disruption notifications
   - Alternative options

6. Production Features:
   - Booking management dashboard
   - Itinerary sharing
   - Mobile app integration
   - 24/7 customer support
   - Multi-language support
"""


if __name__ == "__main__":
    main()
'''
