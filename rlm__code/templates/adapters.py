"""
DSPy Adapter Templates

This module provides templates for all major DSPy adapters including:
- JSONAdapter: For structured JSON output
- XMLAdapter: For XML-formatted output
- ChatAdapter: For chat-based interactions (default)
- TwoStepAdapter: For two-stage processing with reasoning models

Each template includes complete working code with examples.
"""

from dataclasses import dataclass


@dataclass
class AdapterInfo:
    """Information about an adapter."""

    name: str
    display_name: str
    description: str
    best_for: str
    requires: list
    difficulty: str
    keywords: list


class AdapterTemplates:
    """Registry of DSPy adapter templates."""

    def __init__(self):
        self.adapters = {
            "json": self._json_info(),
            "xml": self._xml_info(),
            "chat": self._chat_info(),
            "two_step": self._two_step_info(),
        }

    def list_all(self) -> list[AdapterInfo]:
        """List all available adapters."""
        return list(self.adapters.values())

    def get_adapter_code(self, name: str, use_case: str = "classification") -> str | None:
        """Get complete code for an adapter."""
        generators = {
            "json": self._generate_json,
            "xml": self._generate_xml,
            "chat": self._generate_chat,
            "two_step": self._generate_two_step,
        }

        generator = generators.get(name)
        return generator(use_case) if generator else None

    def search(self, query: str) -> list[AdapterInfo]:
        """Search adapters by keywords."""
        query_lower = query.lower()
        matches = []

        for adapter in self.adapters.values():
            if (
                any(kw in query_lower for kw in adapter.keywords)
                or query_lower in adapter.best_for.lower()
            ):
                matches.append(adapter)

        return matches

    # Adapter Info Methods

    def _json_info(self) -> AdapterInfo:
        return AdapterInfo(
            name="json",
            display_name="JSONAdapter",
            description="Structured JSON output with native function calling support",
            best_for="Structured data extraction, API responses, when you need JSON format",
            requires=["model with JSON mode support"],
            difficulty="beginner",
            keywords=["json", "structured", "api", "extraction", "format"],
        )

    def _xml_info(self) -> AdapterInfo:
        return AdapterInfo(
            name="xml",
            display_name="XMLAdapter",
            description="XML-formatted output for structured responses",
            best_for="XML-based systems, when you need XML format, legacy integrations",
            requires=["model that can generate XML"],
            difficulty="beginner",
            keywords=["xml", "structured", "format", "legacy"],
        )

    def _chat_info(self) -> AdapterInfo:
        return AdapterInfo(
            name="chat",
            display_name="ChatAdapter",
            description="Default chat-based adapter for natural language interactions",
            best_for="General use, chat-based interactions, default choice",
            requires=["any model"],
            difficulty="beginner",
            keywords=["chat", "default", "natural", "conversation"],
        )

    def _two_step_info(self) -> AdapterInfo:
        return AdapterInfo(
            name="two_step",
            display_name="TwoStepAdapter",
            description="Two-stage processing: main LM for reasoning, smaller LM for extraction",
            best_for="Reasoning models (o3, o1), when main model struggles with structured output",
            requires=["main LM (reasoning model)", "extraction LM (smaller model)"],
            difficulty="advanced",
            keywords=["two-step", "reasoning", "extraction", "o3", "o1", "structured"],
        )

    # Template Generation Methods

    def _generate_json(self, use_case: str = "classification") -> str:
        """Generate JSONAdapter template."""
        return '''"""
JSONAdapter Example - Structured JSON Output

JSONAdapter provides structured JSON output with native function calling support.
It automatically uses structured outputs when supported by the model, otherwise
falls back to JSON mode.

Generated by RLM Code - Adapter Template
"""

import dspy

# ============================================================================
# 1. CONFIGURE DSPy WITH JSONAdapter
# ============================================================================

# Configure DSPy to use JSONAdapter
dspy.configure(
    lm=dspy.LM(model="openai/gpt-4o"),  # Use a model that supports JSON
    adapter=dspy.JSONAdapter()
)

# ============================================================================
# 2. DEFINE SIGNATURE WITH STRUCTURED OUTPUT
# ============================================================================

class ClassificationSignature(dspy.Signature):
    """Classify text into categories."""
    text = dspy.InputField(desc="Text to classify")
    category = dspy.OutputField(desc="Classification category")
    confidence = dspy.OutputField(desc="Confidence score (0-1)")


# ============================================================================
# 3. CREATE PREDICTOR WITH JSONAdapter
# ============================================================================

classifier = dspy.ChainOfThought(ClassificationSignature)

# ============================================================================
# 4. USE THE PREDICTOR
# ============================================================================

def classify_text(text: str):
    """Classify text using JSONAdapter."""
    result = classifier(text=text)
    print(f"Category: {result.category}")
    print(f"Confidence: {result.confidence}")
    return result


# ============================================================================
# 5. EXAMPLE WITH NESTED STRUCTURE
# ============================================================================

import pydantic

class Address(pydantic.BaseModel):
    """Address structure."""
    street: str = pydantic.Field(description="Street address")
    city: str = pydantic.Field(description="City name")
    zip_code: str = pydantic.Field(description="ZIP code")


class PersonInfo(dspy.Signature):
    """Extract person information."""
    text = dspy.InputField(desc="Text containing person information")
    name = dspy.OutputField(desc="Person's name")
    age = dspy.OutputField(desc="Person's age")
    address = Address = dspy.OutputField(desc="Person's address")


extractor = dspy.Predict(PersonInfo)

# ============================================================================
# 6. ADVANCED: CUSTOM JSON SCHEMA
# ============================================================================

# JSONAdapter automatically generates JSON schema from signature fields
# For custom schemas, you can use Pydantic models as shown above

# ============================================================================
# 7. BENEFITS OF JSONAdapter
# ============================================================================

"""
Benefits:
- Structured output guaranteed to be valid JSON
- Native function calling support
- Automatic fallback to JSON mode if structured outputs not supported
- Works with Pydantic models for complex structures
- Better parsing reliability than text-based adapters
"""

if __name__ == "__main__":
    # Example usage
    result = classify_text("This product is amazing! I love it.")
    print(f"\\nResult: {result}")
'''

    def _generate_xml(self, use_case: str = "classification") -> str:
        """Generate XMLAdapter template."""
        return '''"""
XMLAdapter Example - XML-Formatted Output

XMLAdapter formats inputs and outputs using XML tags, making it easy to
parse structured data from XML-based systems.

Generated by RLM Code - Adapter Template
"""

import dspy

# ============================================================================
# 1. CONFIGURE DSPy WITH XMLAdapter
# ============================================================================

# Configure DSPy to use XMLAdapter
dspy.configure(
    lm=dspy.LM(model="openai/gpt-4o"),
    adapter=dspy.XMLAdapter()
)

# ============================================================================
# 2. DEFINE SIGNATURE
# ============================================================================

class ExtractionSignature(dspy.Signature):
    """Extract information from text."""
    text = dspy.InputField(desc="Text to extract information from")
    entity = dspy.OutputField(desc="Extracted entity name")
    type = dspy.OutputField(desc="Entity type")
    confidence = dspy.OutputField(desc="Extraction confidence")


# ============================================================================
# 3. CREATE PREDICTOR
# ============================================================================

extractor = dspy.ChainOfThought(ExtractionSignature)

# ============================================================================
# 4. USE THE PREDICTOR
# ============================================================================

def extract_entity(text: str):
    """Extract entity using XMLAdapter."""
    result = extractor(text=text)
    print(f"Entity: {result.entity}")
    print(f"Type: {result.type}")
    print(f"Confidence: {result.confidence}")
    return result


# ============================================================================
# 5. XML FORMAT EXAMPLE
# ============================================================================

"""
XMLAdapter formats data like this:

Input:
<text>
John Smith works at Microsoft in Seattle.
</text>

Output:
<entity>
John Smith
</entity>

<type>
PERSON
</type>

<confidence>
0.95
</confidence>
"""

# ============================================================================
# 6. WHEN TO USE XMLAdapter
# ============================================================================

"""
Use XMLAdapter when:
- Integrating with XML-based systems
- You need human-readable structured output
- Working with legacy systems that expect XML
- You prefer XML over JSON for readability
"""

if __name__ == "__main__":
    # Example usage
    result = extract_entity("Apple Inc. was founded by Steve Jobs in Cupertino.")
    print(f"\\nResult: {result}")
'''

    def _generate_chat(self, use_case: str = "classification") -> str:
        """Generate ChatAdapter template."""
        return '''"""
ChatAdapter Example - Default Chat-Based Adapter

ChatAdapter is the default adapter in DSPy. It formats interactions as
natural chat conversations, making it ideal for conversational AI applications.

Generated by RLM Code - Adapter Template
"""

import dspy

# ============================================================================
# 1. CONFIGURE DSPy WITH ChatAdapter (DEFAULT)
# ============================================================================

# ChatAdapter is the default, but you can explicitly configure it
dspy.configure(
    lm=dspy.LM(model="openai/gpt-4o"),
    adapter=dspy.ChatAdapter()  # This is the default
)

# ============================================================================
# 2. DEFINE SIGNATURE
# ============================================================================

class QASignature(dspy.Signature):
    """Answer questions naturally."""
    question = dspy.InputField(desc="User's question")
    answer = dspy.OutputField(desc="Natural language answer")


# ============================================================================
# 3. CREATE PREDICTOR
# ============================================================================

qa_system = dspy.ChainOfThought(QASignature)

# ============================================================================
# 4. USE THE PREDICTOR
# ============================================================================

def answer_question(question: str):
    """Answer question using ChatAdapter."""
    result = qa_system(question=question)
    print(f"Q: {question}")
    print(f"A: {result.answer}")
    return result


# ============================================================================
# 5. CONVERSATIONAL EXAMPLE
# ============================================================================

class ConversationSignature(dspy.Signature):
    """Maintain conversation context."""
    history = dspy.InputField(desc="Conversation history")
    user_message = dspy.InputField(desc="Current user message")
    response = dspy.OutputField(desc="Assistant response")


conversation = dspy.ChainOfThought(ConversationSignature)

# ============================================================================
# 6. CHAT FORMAT EXAMPLE
# ============================================================================

"""
ChatAdapter formats interactions as natural conversations:

System: You are a helpful assistant.
User: What is the capital of France?
Assistant: The capital of France is Paris.
"""

# ============================================================================
# 7. WHEN TO USE ChatAdapter
# ============================================================================

"""
Use ChatAdapter when:
- Building conversational AI applications
- You want natural language interactions
- Working with chat-based models
- You don't need strict structured output
- This is the default and works for most cases
"""

if __name__ == "__main__":
    # Example usage
    result = answer_question("What is machine learning?")
    print(f"\\nResult: {result}")
'''

    def _generate_two_step(self, use_case: str = "classification") -> str:
        """Generate TwoStepAdapter template."""
        return '''"""
TwoStepAdapter Example - Two-Stage Processing

TwoStepAdapter uses a two-stage approach:
1. Main LM (reasoning model like o3, o1) generates natural response
2. Smaller extraction LM extracts structured data from the response

This is ideal when your main model struggles with structured output.

Generated by RLM Code - Adapter Template
"""

import dspy

# ============================================================================
# 1. CONFIGURE TWO MODELS
# ============================================================================

# Main model: Reasoning model (o3, o1, etc.)
main_lm = dspy.LM(
    model="openai/o3-mini",
    max_tokens=16000,
    temperature=1.0
)

# Extraction model: Smaller, cheaper model for structured extraction
extraction_lm = dspy.LM(model="openai/gpt-4o-mini")

# ============================================================================
# 2. CREATE TwoStepAdapter
# ============================================================================

# TwoStepAdapter uses main_lm for reasoning, extraction_lm for extraction
adapter = dspy.TwoStepAdapter(extraction_model=extraction_lm)

# ============================================================================
# 3. CONFIGURE DSPy
# ============================================================================

dspy.configure(
    lm=main_lm,  # Main reasoning model
    adapter=adapter  # Two-step adapter
)

# ============================================================================
# 4. DEFINE SIGNATURE
# ============================================================================

class ComplexReasoningSignature(dspy.Signature):
    """Complex reasoning task with structured output."""
    problem = dspy.InputField(desc="Complex problem to solve")
    reasoning = dspy.OutputField(desc="Step-by-step reasoning")
    answer = dspy.OutputField(desc="Final answer")
    confidence = dspy.OutputField(desc="Confidence level")


# ============================================================================
# 5. CREATE PREDICTOR
# ============================================================================

reasoner = dspy.ChainOfThought(ComplexReasoningSignature)

# ============================================================================
# 6. USE THE PREDICTOR
# ============================================================================

def solve_problem(problem: str):
    """Solve complex problem using TwoStepAdapter."""
    result = reasoner(problem=problem)
    print(f"Problem: {problem}")
    print(f"\\nReasoning: {result.reasoning}")
    print(f"\\nAnswer: {result.answer}")
    print(f"Confidence: {result.confidence}")
    return result


# ============================================================================
# 7. HOW TwoStepAdapter WORKS
# ============================================================================

"""
Step 1: Main LM (o3-mini) receives the problem and generates a natural
        language response with reasoning.

Step 2: Extraction LM (gpt-4o-mini) receives the main LM's response and
        extracts structured fields (reasoning, answer, confidence) using
        ChatAdapter.

This approach leverages the reasoning capabilities of models like o3 while
ensuring structured output extraction.
"""

# ============================================================================
# 8. WHEN TO USE TwoStepAdapter
# ============================================================================

"""
Use TwoStepAdapter when:
- Using reasoning models (o3, o1) that struggle with structured output
- You need both reasoning and structured extraction
- Cost optimization: use expensive model for reasoning, cheap for extraction
- Main model doesn't support structured outputs well
"""

# ============================================================================
# 9. COST OPTIMIZATION TIP
# ============================================================================

"""
Cost breakdown:
- Main LM (o3-mini): Used for complex reasoning (expensive)
- Extraction LM (gpt-4o-mini): Used only for simple extraction (cheap)

This can be more cost-effective than using a single expensive model
for both reasoning and structured output.
"""

if __name__ == "__main__":
    # Example usage
    problem = "If a train travels 60 mph for 2.5 hours, then slows to 40 mph for 1 hour, what's the total distance?"
    result = solve_problem(problem)
    print(f"\\nResult: {result}")
'''
